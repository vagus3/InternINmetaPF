
export const developmentData = {
  summary: {
    title: '💻 개발',
    description: '최신 웹 프레임워크 트렌드, 상태 관리 라이브러리, 그리고 생산성을 높이는 개발 기법 등 끊임없이 변화하는 개발 생태계의 주요 소식을 깊이 있게 다룹니다.'
  },
  details: [
    {
    id: 'dev1',
    bigTitle: '소프트웨어 요구사항 분석과 작업 분배',
    sections: [
      {
        subTitle: '1. 요구사항의 정의와 중요성',
        content: '요구사항은 소프트웨어 개발의 기준과 근거를 제공하며, 모든 이해관계자 간의 원활한 의사소통을 돕는 핵심 요소입니다. 프로젝트의 목표와 계획을 수립하는 데 가장 기본적인 근거로 사용됩니다.'
      },
      {
        subTitle: '2. 요구사항의 체계적 분류',
        content: '기능(동작), 성능(속도/용량), 인터페이스(UI/UX), 데이터, 품질, 보안, 프로젝트 관리 및 지원 등 다양한 유형으로 분류하여 체계적으로 관리합니다.'
      },
      {
        subTitle: '3. 효과적인 요구사항 수집 방법',
        content: '이해관계자 목록을 바탕으로 현업 및 IT 담당자를 선정하고 사전 질의서를 공유합니다. 사용자에게는 기능/인터페이스를, 운영자에게는 성능/보안을 중심으로 질문하여 요구사항을 상세히 도출합니다.'
      },
      {
        subTitle: '4. 요구사항 분석 및 명세화 예시',
        content: "예시) 기능: '전자결재 연동', 성능: '동시 사용자 500명 지원', 보안: 'PKI 기반 접근 제어', 지원: '12개월 무상 하자보수' 등 구체적인 목표를 명세화합니다."
      },
      {
        subTitle: '5. 요구사항 기반 작업 분배 전략',
        content: '분석된 요구사항을 기반으로 작업을 분류하고 우선순위를 결정하여 일정을 계획합니다. 이후 계획에 따라 인력을 할당하고 진행 상황을 지속적으로 모니터링하며 조정합니다.'
      }
    ]
  },
    {
    id: 'dev2',
    bigTitle: 'TDD (Test-Driven Development) 핵심 가이드',
    sections: [
      {
        subTitle: '1. TDD(Test-Driven Development)란?',
        content: '테스트가 개발을 주도하는 소프트웨어 개발 방법론입니다. 비즈니스 코드를 작성하기 전에 실패하는 테스트 케이스를 먼저 만들고, 이를 통과시키는 코드를 추가하는 과정을 짧은 사이클로 반복합니다. 작은 단위의 테스트를 통해 소프트웨어를 안정적으로 구현하는 것을 목적으로 합니다.'
      },
      {
        subTitle: '2. TDD의 프로세스: RED-GREEN-REFACTOR',
        content: 'TDD는 RED(실패하는 테스트 작성) → GREEN(테스트를 통과할 최소 코드 작성) → REFACTOR(코드 리팩토링) 사이클을 반복합니다. 이 과정을 통해 불필요한 설계를 피하고 요구사항에 집중하여 코드를 점진적으로 개선합니다.'
      },
      {
        subTitle: '3. 일반 개발 방식 vs TDD',
        content: '일반 방식(디자인 → 코드 → 테스트)은 초기 설계가 불완전할 경우 재설계 비용이 크고 품질 저하가 발생하기 쉽습니다. 반면 TDD(디자인 → 테스트 코드 → 코드 → 설계 수정)는 테스트 케이스를 미리 정의하여 버그 감소, 코드 간결화, 재설계 시간 절감 효과를 가져옵니다.'
      },
      {
        subTitle: '4. TDD의 종류와 테스트 수준',
        content: '테스트 수준에 따라 단위(Unit), 컴포넌트(Widget), 통합(Integration) 테스트로 나뉩니다. 단위 테스트는 실행 속도가 가장 빠르고 유지 비용이 낮은 반면, 통합 테스트는 신뢰도가 가장 높지만 속도가 느리고 비용이 많이 듭니다.'
      },
      {
        subTitle: '5. 단위 테스트의 FIRST 원칙',
        content: '좋은 단위 테스트는 FIRST 원칙을 따릅니다. Fast(빠르게), Independent(독립적으로), Repeatable(반복 가능하게), Self-Validating(자동 검증), Timely(시기적절하게, 실제 코드보다 먼저 작성) 원칙을 통해 테스트의 효율성과 신뢰성을 확보합니다.'
      },
      {
        subTitle: '6. TDD의 장점과 단점',
        content: '장점: 튼튼한 객체 지향 코드 생산, 재설계 및 디버깅 시간 단축, 자연스러운 설계 개선. 단점: 테스트 케이스 작성으로 인한 초기 개발 시간 증가. 단, 이는 장기적인 효율 향상으로 보상되며 훈련을 통해 극복 가능합니다.'
      }
    ]
  },
    {
    id: 'dev3',
    bigTitle: 'Jest 테스팅 프레임워크 가이드',
    sections: [
      {
        subTitle: '1. 테스트 코드를 작성하는 이유',
        content: '소프트웨어의 신뢰성 확보와 버그 예방을 위한 필수 과정입니다. 코드가 의도대로 작동하는지 확인하고, 리팩토링이나 기능 추가 시 발생할 수 있는 부작용(사이드 이펙트)을 방지하며, 디버깅 시간을 단축시키는 장점이 있습니다.'
      },
      {
        subTitle: '2. Jest란? (JavaScript 테스팅 프레임워크)',
        content: 'Facebook에서 만든 자바스크립트 테스팅 프레임워크입니다. 기존의 여러 라이브러리를 조합해야 했던 복잡성을 해결하기 위해 Test Runner, Matcher, Mock 기능을 하나로 통합하여 제공합니다. 설정이 거의 필요 없고, 성능이 우수하며, 코드 커버리지 체크 등 풍부한 기능을 지원합니다.'
      },
      {
        subTitle: '3. Jest 기본 사용법: Matcher',
        content: '테스트 코드의 기본 구조는 `expect(검증 대상).toMatcher(기대 결과)` 형태입니다. `toBe`(원시 타입 비교), `toEqual`(객체/배열 비교), `toBeTruthy`/`toBeFalsy`(참/거짓), `toMatch`(정규식), `toContain`(배열 요소 포함), `toThrow`(에러 발생) 등 다양한 Matcher를 사용하여 정밀한 테스트를 작성할 수 있습니다.'
      },
      {
        subTitle: '4. Jest 비동기 코드 테스트',
        content: '자바스크립트의 비동기 코드를 테스트하기 위한 방법을 지원합니다. 전통적인 콜백(Callback) 방식에서는 `done` 함수를 호출하며, 프로미스(Promise)는 `return` 키워드와 `.then()`을 사용합니다. 가장 현대적인 Async/Await 방식은 코드를 동기식처럼 깔끔하게 작성할 수 있게 해줍니다.'
      },
      {
        subTitle: '5. Jest 테스트 코드 예시',
        content: "간단한 덧셈 함수(`sum.js`)를 테스트하는 코드(`sum.test.js`)는 `test('덧셈 테스트', () => { expect(sum(1, 2)).toBe(3); });`와 같은 형태로 작성합니다. `npm run test` 명령어로 실행하여 결과를 확인할 수 있습니다."
      }
    ]
  },
  {
    id: 'dev4',
    bigTitle: '클린 코드와 코드 리뷰 가이드',
    sections: [
      {
        subTitle: '1. 클린 코드(Clean Code)란?',
        content: '의존성을 최소화하고 구조가 잘 정의된 효율적인 코드를 의미합니다. 가독성이 높고, TDD 기반의 테스트가 존재하며, 중복 없이 작성자의 주의가 기울여진 코드를 말합니다.'
      },
      {
        subTitle: '2. 클린 코드의 중요성',
        content: '이해와 디버깅 시간을 단축하여 개발 비용을 절감하고, 쉬운 유지보수를 통해 안정성을 향상시킵니다. 또한 팀원 간의 협업을 증진시키고, 개발자의 만족도와 자부심을 높여줍니다.'
      },
      {
        subTitle: '3. 클린 코드 작성 기법',
        content: '명확한 명명 규칙, 일관된 들여쓰기, 코드를 작은 단위로 나누는 모듈화, 간결한 주석 사용, 그리고 정기적인 코드 검토 및 리팩토링을 통해 작성할 수 있습니다.'
      },
      {
        subTitle: '4. 코드 리뷰(Code Review)란?',
        content: '한 명 이상의 개발자가 다른 사람의 코드를 점검하여 잠재적 결함을 찾고 개선하는 활동입니다. 버그를 조기에 발견하고, 개발 표준을 준수하며, 팀의 전체적인 개발 역량을 상향 평준화시키는 가장 효과적인 방법 중 하나입니다.'
      },
      {
        subTitle: '5. 코드 리뷰에서 점검할 것들',
        content: '기능이 의도대로 동작하는지 확인하고, 잠재적인 버그를 찾습니다. 또한, 가독성, 유지보수성, 개발 표준 준수 여부, 테스트 코드 작성 여부, 기존 코드와의 중복 여부 등을 종합적으로 검토하며 배울 점을 찾습니다.'
      },
      {
        subTitle: '6. 코드 리뷰의 핵심 개념: 코드 스멜(Code Smells)',
        content: "리팩토링이 필요한 코드의 '나쁜 냄새'를 의미합니다. 대표적인 예로 중복된 코드, 너무 긴 메서드(장황한 메서드), 과도하게 많은 매개변수, 여러 곳에 흩어진 기능, 상수의 직접 사용(매직 넘버) 등이 있습니다."
      },
      {
        subTitle: '7. 피해야 할 안티패턴(Anti-patterns)',
        content: '비효율적인 코딩 습관으로, 예를 들어 한 줄 반복문, 불필요한 주석, 과도한 예외 처리, 이미 있는 라이브러리 기능을 직접 재구현하는 등의 패턴을 지양해야 합니다.'
      }
    ]
  },
  {
    id: 'dev5',
    bigTitle: '프로젝트 배포와 README 작성 가이드',
    sections: [
      {
        subTitle: '1. Netlify를 이용한 정적 사이트 배포',
        content: 'Github 등과 연동하여 정적 사이트를 쉽게 호스팅하는 서비스입니다. 무료 용량(100GB), 자동 SSL, CI/CD를 제공합니다. 배포 과정은 Netlify 회원가입 → \'Import from Git\'으로 Github 저장소 선택 → 빌드 옵션 설정 후 배포 버튼 클릭 순으로 진행되며, 완료 후 제공되는 URL을 커스텀할 수 있습니다.'
      },
      {
        subTitle: '2. Github Pages를 이용한 정적 사이트 배포',
        content: 'Github에서 직접 제공하는 무료 정적 사이트 호스팅 서비스입니다. Public 레포지토리에서 무료로 사용할 수 있으며, `github.io` 도메인을 제공합니다. 배포는 레포지토리의 \'Settings → Pages\'에서 배포할 브랜치를 선택하는 간단한 과정으로 완료됩니다. React 프로젝트의 경우 `gh-pages` 라이브러리를 사용하면 더 편리합니다.'
      },
      {
        subTitle: '3. 프로젝트의 첫인상: README.md 작성법',
        content: 'Github 레포지토리의 설명 파일로, 프로젝트의 필수 정보(설치, 사용법 등)를 제공하는 얼굴과도 같습니다. \'마크다운(Markdown)\'이라는 읽고 쓰기 쉬운 마크업 언어를 사용하여 작성합니다.'
      },
      {
        subTitle: '4. 기본 마크다운(Markdown) 문법',
        content: '제목(#), 목록(*, 1.), 기울임/굵은 글씨(**텍스트**), 인용(>), 코드 블록(```) 등 간단한 문법을 조합하여 가독성 높은 문서를 만들 수 있습니다.'
      },
      {
        subTitle: '5. README.md 생성 및 관리',
        content: 'Github 레포지토리에서 \'Add a README\' 버튼으로 생성할 수 있으며, 펜 아이콘(Edit)을 눌러 언제든지 수정할 수 있습니다. 모든 변경 사항은 Git으로 버전 관리되어 히스토리 확인이 가능합니다.'
      }
    ]
  }
  ]
};

export const socialData = {
  summary: {
    title: '🌍 사회',
    description: '디지털 네이티브 세대의 특징부터 인공지능이 가져올 사회 변화까지, 기술 발전이 우리 사회에 미치는 다양한 영향을 분석하고 미래를 전망합니다.'
  },
  details: [
    { id: 'soc1', bigTitle: '디지털 네이티브 세대의 특징', sections: [{ subTitle: '숏폼 콘텐츠 소비', content: '1분 내외의 짧은 영상에 대한 선호도가 높아지고 있습니다.' }] },
    { id: 'soc2', bigTitle: '인공지능과 사회 변화', sections: [{ subTitle: '노동 시장의 재편', content: '단순 반복적인 업무는 AI로 대체되고, 인간은 창의적인 역할에 더 집중하게 될 것입니다.' }] },
    { id: 'soc3', bigTitle: '가상현실과 메타버스', sections: [{ subTitle: '새로운 소통 공간의 탄생', content: '메타버스는 단순한 게임을 넘어 사회, 경제, 문화 활동이 이루어지는 새로운 플랫폼으로 자리잡고 있습니다.' }] },
  ]
};

export const etcData = {
  summary: {
    title: '✨ 기타',
    description: '생산성을 높이는 작은 습관, 알아두면 흥미로운 과학 상식 등, 일상에 활력을 더하고 지적 호기심을 채워줄 다양한 이야기를 담았습니다.'
  },
  details: [
    { id: 'etc1', bigTitle: '생산성을 높이는 사소한 습관', sections: [{ subTitle: '2분 규칙', content: '2분 안에 끝낼 수 있는 일은 즉시 처리하는 습관입니다.' }] },
    { id: 'etc2', bigTitle: '흥미로운 우주 과학 사실', sections: [{ subTitle: '중성자별의 밀도', content: '각설탕 하나 크기의 중성자별 조각은 에베레스트 산보다 무겁습니다.' }] },
    { id: 'etc3', bigTitle: '뇌과학과 학습 효율', sections: [{ subTitle: '분산 학습의 효과', content: '한 번에 몰아서 공부하는 것보다 여러 번에 나누어 학습하는 것이 장기 기억에 훨씬 효과적입니다.' }] },
  ]
};